<!doctype html>
<meta charset="utf-8" />
<body>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://dagrejs.github.io/project/dagre/v1.0.4/dagre.js"></script>
    <script src="https://dagrejs.github.io/project/graphlib/v2.1.2/graphlib.min.js"></script>
    <script src="https://dagrejs.github.io/project/dagre-d3/latest/dagre-d3.js"></script>

    <style>
        body {
            font-family: monospace;
        }

        .node {
            white-space: nowrap;
        }

        .node rect,
        .node circle,
        .node ellipse {
            stroke: #333;
            fill: #fff;
            stroke-width: 2px;
        }

        .cluster rect {
            stroke: #333;
            fill: #000;
            fill-opacity: 0.1;
            stroke-width: 2px;
        }

        .edgePath path.path {
            stroke: #333;
            stroke-width: 1.5px;
            fill: none;
        }

        .tooltip-content {
            position: absolute;
            z-index: 10;
            display: block;
        }

        .container {
            display: flex;
            flex-direction: row;
        }

        .legend {
            background: lightgrey;
            width: fit-content;
            display: flex;
            flex-direction: column;
        }

        .legend .legend-item {
            align-items: center;
            display: flex;
            flex-direction: row;
            padding: 5px;
        }

        .legend .legend-arrow {
            font-size: medium;
            margin-left: 7px;
            margin-right: 7px;
        }

        .legend .legend-rectangle {
            width: 60px;
            height: 20px;
            border: 2px solid;
        }

        .legend .dashed-border {
            border: 2px dashed;
        }

        .legend .red-border {
            border: 2px solid #ff0000;
        }

        .legend .red-fill {
            background: #ff0000;
        }

        .legend-table-padding {
            padding-left: 8px;
        }

        .options {
            background: lightgrey;
            width: fit-content;
            display: flex;
            flex-direction: column;
            margin: 0 20px;
        }

        .options .options-title {
            padding: 5px;
        }

        .options .options-row {
            margin: 3px 5px;
            display: flex;
            flex-direction: row;
        }

        .options .options-label {
            width: 200px;
        }

        .svg-container {
            margin: 30px;
        }
    </style>
    <div class="container">
        <div class="legend">
            <div class="legend-item">
                <span><strong>Scope: </strong>INSERT_SCOPE</span>
            </div>
            <div class="legend-item">
                <span><strong>git-revision to compare to: </strong>INSERT_GIT_REVISION</span>
            </div>
            <table style="margin-left: 5px">
                <tr>
                    <td>
                        <label for="graphEdgeDirectionSelect">A<span class="legend-arrow">&#10230;</span>B</label>
                    </td>
                    <td class="legend-table-padding">
                        <select onchange="graphEdgeDirectionSelectCallback(this)" id="graphEdgeDirectionSelect">
                            <option value="A_IMPORTS_B">A depends on B (A imports B)</option>
                            <option value="A_IS_DEPENDENCY_OF_B">A is a dependency of B (B imports A)</option>
                        </select>
                    </td>
                </tr>
                <tr>
                    <td>
                        <div class="legend-rectangle dashed-border"></div>
                    </td>
                    <td class="legend-table-padding">Dashed border: Has no command to execute corresponding to the scope of the graph</td>
                </tr>
                <tr>
                    <td>
                        <div class="legend-rectangle red-border"></div>
                    </td>
                    <td class="legend-table-padding">Red border: A dependency has changed compared to the given git-revision</td>
                </tr>
                <tr>
                    <td>
                        <div class="legend-rectangle red-border red-fill"></div>
                    </td>
                    <td class="legend-table-padding">
                        Red background: File(s) of this project have changed compared to the given git-revision
                    </td>
                </tr>
            </table>
        </div>
        <div class="options">
            <div class="options-title"><strong>Options:</strong></div>
            <div class="options-row">
                <div class="options-label"><label for="graphRenderOrientationSelect">Graph Render Orientation</label></div>
                <div>
                    <select id="graphRenderOrientationSelect" onchange="graphRenderOrientationSelectCallback(this)">
                        <option value="TB">Top to Bottom</option>
                        <option value="BT">Bottom to Top</option>
                        <option value="LR">Left to Right</option>
                        <option value="RL">Right to Left</option>
                    </select>
                </div>
            </div>
            <div class="options-row">
                <div class="options-label"><label for="graphFocusSelect">Focus Project</label></div>
                <div>
                    <select id="graphFocusSelect" onchange="graphFocusSelectCallback(this)">
                        <option value="-----">-----</option>
                    </select>
                </div>
            </div>
            <div class="options-row">
                <div class="options-label"><label for="graphFocusOptionsSelect">Focus Options</label></div>
                <div>
                    <select id="graphFocusOptionsSelect" onchange="graphFocusOptionsSelectCallback(this)"></select>
                </div>
            </div>
        </div>
    </div>
    <div class="svg-container">
        <svg id="svg-id" height="450" width="800" style="display: block">
            <g />
        </svg>
    </div>
    <script>
        /**
         * This corresponds to "YaniceGraphNodeInfo" (see graph-dagre-renderer.ts):
         *
         * @typedef {Object} YaniceGraphNodeInfo
         * @property {string} projectName
         * @property {string} scope
         * @property {string[]} parents
         * @property {string[]} children
         * @property {string[]} ancestors
         * @property {string[]} descendants
         * @property {string[]} responsibles
         * @property {string[]} changedFiles
         * @property {boolean} isAffected
         * @property {YaniceCommand|null} command
         * @property {string} pathGlob
         * @property {string} pathRegExp
         *
         */

        /**
         * @typedef {Object} RenderOptions
         * @property {"TB"|"BT"|"LR"|"RL"} graphRenderDirection
         * @property {"A_IS_DEPENDENCY_OF_B"|"A_IMPORTS_B"} graphEdgeDirection
         * @property {string} graphFocus
         * @property {"DESCENDANTS_ONLY"|"ANCESTORS_ONLY"|"ANCESTORS_AND_DESCENDANTS"|"IMMEDIATE_CONNECTIONS"} graphFocusOptions
         */

        const GRAPH_FOCUS_DEFAULT = '-----';
        const YANICE_RENDER_OPTIONS_SESSION_STORAGE_KEY = 'yanice-render-options';

        /**
         * @type {RenderOptions}
         */
        const DEFAULT_RENDER_OPTIONS = {
            graphRenderDirection: 'BT', // TB | BT | LR | RL
            graphEdgeDirection: 'A_IMPORTS_B', // A_IS_DEPENDENCY_OF_B | A_IMPORTS_B
            graphFocus: GRAPH_FOCUS_DEFAULT, // ----- is nothing focused, otherwise name of the project,
            graphFocusOptions: 'DESCENDANTS_ONLY' // see method setFocusOptionsSelectDefaultValue
        };

        // Allow the browser to already render the static parts
        setTimeout(() => main());

        function main() {
            console.time('main.setup');

            /**
             * These values will be filled in graph-dagre-renderer.ts:
             * @type {YaniceGraphNodeInfo[]}
             */
            const yaniceGraphNodeInfos = INSERT_GRAPH_DATA_OBJECT_HERE;

            /**
             *
             * @type {Map<string, YaniceGraphNodeInfo>}
             */
            const projectNameToGraphNodeInfoMap = new Map();

            yaniceGraphNodeInfos.forEach((entry) => {
                projectNameToGraphNodeInfoMap.set(entry.projectName, entry);
            });

            /**
             * @type {RenderOptions}
             */
            const renderOptions = getRenderOptionsFromSessionStorageOrDefault();

            /**
             * @type {Set<string>}
             */
            const renderedProjects = getProjectsThatNeedRendering(yaniceGraphNodeInfos, renderOptions);

            setDefaultValuesInSelects(yaniceGraphNodeInfos, renderOptions);

            const dagreGraph = createDagreGraph(yaniceGraphNodeInfos, renderedProjects, projectNameToGraphNodeInfoMap, renderOptions);

            enableZoom();

            console.timeEnd('main.setup');

            console.time('dagre.layout');
            dagre.layout(dagreGraph);
            console.timeEnd('dagre.layout');

            console.time('dagreD3.render');
            renderGraph(dagreGraph);
            console.timeEnd('dagreD3.render');

            const svgHeight = dagreGraph.graph().height * 1.2;
            const svgWidth = dagreGraph.graph().width * 1.2;
            document.getElementById('svg-id').setAttribute('height', svgHeight + 'px');
            document.getElementById('svg-id').setAttribute('width', svgWidth + 'px');

            setupTooltipOnHover(dagreGraph, projectNameToGraphNodeInfoMap);
        }

        // =========== GRAPH ===========

        /**
         * @param yaniceGraphNodeInfos {YaniceGraphNodeInfo[]}
         * @param renderedProjects {Set<string>}
         * @param projectNameToGraphNodeInfoMap {Map<string, YaniceGraphNodeInfo>}
         * @param renderOptions {RenderOptions}
         * @return dagreGraph
         */
        function createDagreGraph(yaniceGraphNodeInfos, renderedProjects, projectNameToGraphNodeInfoMap, renderOptions) {
            // Initialize an empty graph
            const dagreGraph = new dagreD3.graphlib.Graph().setGraph({});

            // Set up all nodes/edges. Note that when iterating over nodes with d3, the data that is given here
            // is available: See e.g. "dagreGraph.node(d)"-usages below
            yaniceGraphNodeInfos
                .filter((nodeInfo) => renderedProjects.has(nodeInfo.projectName))
                .forEach((nodeInfo) => {
                    const d3NodeData = {
                        label: nodeInfo.projectName,
                        style: getNodeStyle(nodeInfo)
                    };

                    dagreGraph.setNode(nodeInfo.projectName, d3NodeData);
                    switch (renderOptions.graphEdgeDirection) {
                        case 'A_IS_DEPENDENCY_OF_B':
                            nodeInfo.parents
                                .filter((e) => renderedProjects.has(e))
                                .forEach((e) =>
                                    dagreGraph.setEdge(nodeInfo.projectName, e, {
                                        curve: d3.curveBasis,
                                        style: getEdgeStyle(nodeInfo, projectNameToGraphNodeInfoMap.get(e))
                                    })
                                );
                            break;
                        case 'A_IMPORTS_B':
                            nodeInfo.parents
                                .filter((e) => renderedProjects.has(e))
                                .forEach((e) =>
                                    dagreGraph.setEdge(e, nodeInfo.projectName, {
                                        curve: d3.curveBasis,
                                        style: getEdgeStyle(nodeInfo, projectNameToGraphNodeInfoMap.get(e))
                                    })
                                );
                            break;
                    }
                });

            // Add some margins (otherwise the graph looks a bit cut-off at the borders)
            if (!dagreGraph.graph().hasOwnProperty('marginx') && !dagreGraph.graph().hasOwnProperty('marginy')) {
                dagreGraph.graph().marginx = 20;
                dagreGraph.graph().marginy = 20;
            }
            // Graph direction
            dagreGraph.graph().rankdir = renderOptions.graphRenderDirection;
            return dagreGraph;
        }

        function renderGraph(dagreGraph) {
            const render = dagreD3.render();
            render(d3.select('svg g'), dagreGraph);
        }

        // =========== SELECT-CALLBACKS ===========

        function graphEdgeDirectionSelectCallback(selectElement) {
            const options = getRenderOptionsFromSessionStorageOrDefault();
            const newOptions = {
                ...options,
                graphEdgeDirection: selectElement.value
            };
            writeOptionsToSessionStorageAndReload(newOptions);
        }

        function graphRenderOrientationSelectCallback(selectElement) {
            const options = getRenderOptionsFromSessionStorageOrDefault();
            const newOptions = {
                ...options,
                graphRenderDirection: selectElement.value
            };
            writeOptionsToSessionStorageAndReload(newOptions);
        }

        function graphFocusSelectCallback(selectElement) {
            const options = getRenderOptionsFromSessionStorageOrDefault();
            const newOptions = {
                ...options,
                graphFocus: selectElement.value
            };
            writeOptionsToSessionStorageAndReload(newOptions);
        }

        function graphFocusOptionsSelectCallback(selectElement) {
            const options = getRenderOptionsFromSessionStorageOrDefault();
            const newOptions = {
                ...options,
                graphFocusOptions: selectElement.value
            };
            writeOptionsToSessionStorageAndReload(newOptions);
        }

        // =========== SELECT-SETUP ==============

        /**
         * @param yaniceGraphNodeInfos {YaniceGraphNodeInfo[]}
         * @param renderOptions {RenderOptions}
         */
        function setDefaultValuesInSelects(yaniceGraphNodeInfos, renderOptions) {
            setEdgeDirectionSelectDefaultValue(renderOptions);
            setRenderOrientationSelectDefaultValue(renderOptions);
            setFocusProjectOptions(yaniceGraphNodeInfos, renderOptions);
            setFocusOptionsSelectDefaultValue(renderOptions);
        }

        /**
         * @param renderOptions {RenderOptions}
         */
        function setEdgeDirectionSelectDefaultValue(renderOptions) {
            const selectedEdgeDirectionIndex = renderOptions.graphEdgeDirection === 'A_IS_DEPENDENCY_OF_B' ? 1 : 0;
            document.querySelector('#graphEdgeDirectionSelect').options[selectedEdgeDirectionIndex].selected = true;
        }

        /**
         @param renderOptions {RenderOptions}
         */
        function setRenderOrientationSelectDefaultValue(renderOptions) {
            const renderDirectionToIndexMap = {
                TB: 0,
                BT: 1,
                LR: 2,
                RL: 3
            };
            const selectedRenderOrientationOptionIndex = renderDirectionToIndexMap[renderOptions.graphRenderDirection] ?? 0;
            document.querySelector('#graphRenderOrientationSelect').options[selectedRenderOrientationOptionIndex].selected = true;
        }

        /**
         * @param yaniceGraphNodeInfos {YaniceGraphNodeInfo[]}
         * @param renderOptions {RenderOptions}
         */
        function setFocusProjectOptions(yaniceGraphNodeInfos, renderOptions) {
            yaniceGraphNodeInfos.forEach((nodeInfo) => {
                const select = document.querySelector('#graphFocusSelect');
                select.options[select.options.length] = new Option(
                    nodeInfo.projectName,
                    nodeInfo.projectName,
                    renderOptions.graphFocus === nodeInfo.projectName,
                    renderOptions.graphFocus === nodeInfo.projectName
                );
            });
        }

        /**
         * @param renderOptions {RenderOptions}
         */
        function setFocusOptionsSelectDefaultValue(renderOptions) {
            const graphFocusOptions = [
                { value: 'DESCENDANTS_ONLY', label: 'All transitive dependencies' },
                { value: 'ANCESTORS_ONLY', label: 'All transitive dependants' },
                { value: 'ANCESTORS_AND_DESCENDANTS', label: 'All transitive dependencies and dependants' },
                { value: 'IMMEDIATE_CONNECTIONS', label: 'Only direct dependencies and dependants' }
            ];
            const selectElement = document.querySelector('#graphFocusOptionsSelect');
            graphFocusOptions.forEach((option) => {
                selectElement.options[selectElement.options.length] = new Option(
                    option.label,
                    option.value,
                    renderOptions.graphFocusOptions === option.value,
                    renderOptions.graphFocusOptions === option.value
                );
            });
            if (renderOptions.graphFocus === GRAPH_FOCUS_DEFAULT) {
                selectElement.disabled = true;
            }
        }

        // =========== UTILITIES ==============

        function enableZoom() {
            const svg = d3.select('svg'),
                inner = d3.select('svg g'),
                zoom = d3.zoom().on('zoom', function () {
                    inner.attr('transform', d3.event.transform);
                });
            svg.call(zoom);
        }

        /**
         * @param dagreGraph
         * @param projectNameToGraphNodeInfoMap {Map<string, YaniceGraphNodeInfo>}
         */
        function setupTooltipOnHover(dagreGraph, projectNameToGraphNodeInfoMap) {
            // Attach tooltip-div. Note that there is only one such div, which will be rendered depending on which
            // graph-node (project) is currently being hovered. If none is hovered, the tooltip-div is hidden
            const tooltip = d3
                .select('.svg-container')
                .append('div')
                .attr('class', 'tooltip-content')
                .style('visibility', 'hidden')
                .style('border', 'solid')
                .style('min-width', '600px')
                .style('border-width', '2px')
                .style('border-radius', '5px')
                .style('padding', '5px')
                .style('background-color', 'white');

            const mouseover = function (d) {
                const d3Node = dagreGraph.node(d);
                tooltip
                    .style('visibility', 'visible')
                    .html(getProjectInfoTable(projectNameToGraphNodeInfoMap.get(d3Node.label)))
                    .style('left', d3Node.x + 'px')
                    .style('top', d3Node.y + 50 + 'px'); // the +50 takes makes the tooltip appear below the node
                // TODO: Take zoom into account - zooming currently breaks tooltip-positioning
            };
            const mouseout = function (d) {
                tooltip.style('visibility', 'hidden');
            };

            d3.selectAll('g.node').on('mouseover', mouseover).on('mouseout', mouseout);
        }

        /**
         *
         * @returns {RenderOptions}
         */
        function getRenderOptionsFromSessionStorageOrDefault() {
            const optionsFromSessionStorage = sessionStorage.getItem(YANICE_RENDER_OPTIONS_SESSION_STORAGE_KEY);
            return optionsFromSessionStorage ? JSON.parse(optionsFromSessionStorage) : DEFAULT_RENDER_OPTIONS;
        }

        /**
         * @param graphDisplayOptions {RenderOptions}
         */
        function writeOptionsToSessionStorageAndReload(graphDisplayOptions) {
            sessionStorage.setItem(YANICE_RENDER_OPTIONS_SESSION_STORAGE_KEY, JSON.stringify(graphDisplayOptions));
            window.location.reload();
        }

        /**
         * @param yaniceGraphNodeInfos {YaniceGraphNodeInfo[]}
         * @param renderOptions {RenderOptions}
         * @returns {Set<string>}
         */
        function getProjectsThatNeedRendering(yaniceGraphNodeInfos, renderOptions) {
            const allProjects = yaniceGraphNodeInfos.map((d) => d.projectName);
            if (renderOptions.graphFocus === GRAPH_FOCUS_DEFAULT) {
                return new Set(allProjects);
            }

            const focusProjectGraphData = yaniceGraphNodeInfos.find((d) => d.projectName === renderOptions.graphFocus);
            console.log('focusProjectGraphData', focusProjectGraphData);
            switch (renderOptions.graphFocusOptions) {
                case 'ANCESTORS_ONLY':
                    return new Set([focusProjectGraphData.projectName, ...focusProjectGraphData.ancestors]);
                case 'DESCENDANTS_ONLY':
                    return new Set([focusProjectGraphData.projectName, ...focusProjectGraphData.descendants]);
                case 'ANCESTORS_AND_DESCENDANTS':
                    return new Set([
                        focusProjectGraphData.projectName,
                        ...focusProjectGraphData.descendants,
                        ...focusProjectGraphData.ancestors
                    ]);
                case 'IMMEDIATE_CONNECTIONS':
                    return new Set([
                        focusProjectGraphData.projectName,
                        ...focusProjectGraphData.parents,
                        ...focusProjectGraphData.children
                    ]);
            }
        }

        /**
         * @param yaniceGraphNodeInfo {YaniceGraphNodeInfo}
         * @returns {string}
         */
        function getNodeStyle(yaniceGraphNodeInfo) {
            let styleStr = 'stroke-width: 2px;';
            // If there is no command, the graph-node has dashed borders
            if (!yaniceGraphNodeInfo.command) {
                styleStr = styleStr.concat('stroke-dasharray: 5, 5;');
            }
            // If a project itself or one of its dependencies changed, the outline is red
            if (yaniceGraphNodeInfo.isAffected) {
                styleStr = styleStr.concat('stroke: #ff0000;');
            }
            // If the project itself changed, color the entire node red
            if (yaniceGraphNodeInfo.changedFiles.length > 0) {
                styleStr = styleStr.concat('fill: #ff0000;');
            }
            return styleStr;
        }

        /**
         * @param importerNode {YaniceGraphNodeInfo}
         * @param dependencyNode {YaniceGraphNodeInfo}
         * @returns {string}
         */
        function getEdgeStyle(importerNode, dependencyNode) {
            let styleStr = '';
            if (importerNode.changedFiles.length > 0 && dependencyNode.isAffected) {
                styleStr = styleStr.concat('stroke: #ff0000;');
            }
            return styleStr;
        }

        /**
         * @param yaniceGraphNodeInfo {YaniceGraphNodeInfo}
         * @returns {string}
         */
        function getProjectInfoTable(yaniceGraphNodeInfo) {
            let table = ' <table style="width:100%">';

            // Add basic info: Caption (project-name), pathGlob, pathRegExp
            table = table.concat(
                '<caption><strong>' +
                    yaniceGraphNodeInfo.projectName +
                    '<strong></strong></caption>' +
                    '<tr>' +
                    '  <td>pathGlob:</td>' +
                    '  <td style="font-size: small;white-space:nowrap;">' +
                    yaniceGraphNodeInfo.pathGlob +
                    '</td>' +
                    '</tr>' +
                    '<tr>' +
                    '  <td>pathRegExp:</td>' +
                    '  <td style="font-size: small;white-space:nowrap;">' +
                    yaniceGraphNodeInfo.pathRegExp +
                    '</td>' +
                    '</tr>'
            );

            // Add responsibles, if there are any
            if (yaniceGraphNodeInfo.responsibles.length > 0) {
                table = table.concat(
                    '<tr>' + '  <td>responsibles:</td>' + '  <td>' + yaniceGraphNodeInfo.responsibles.join(', ') + '</td>' + '</tr>'
                );
            }

            // Add commands if defined, add commands-cwd if it's not the root directory
            if (yaniceGraphNodeInfo.command) {
                const commands = yaniceGraphNodeInfo.command.commands;
                const commandDisplayString = commands.length === 1 ? commands[0] : `${commands.join(', ')}`;
                const singularOrPluralCommand = commands.length === 1 ? 'command' : 'commands';
                table = table.concat(
                    '<tr>' +
                        '  <td><span style="font-size: small;white-space: nowrap">' +
                        yaniceGraphNodeInfo.scope +
                        '</span> ' +
                        singularOrPluralCommand +
                        ':</td>' +
                        '  <td style="font-size: small;white-space:nowrap";>' +
                        commandDisplayString +
                        '</td>' +
                        '</tr>'
                );
                if (yaniceGraphNodeInfo.command.cwd && yaniceGraphNodeInfo.command.cwd !== './') {
                    table = table.concat(
                        '<tr>' +
                            '  <td style="white-space:nowrap">command directory:</td>' +
                            '  <td style="font-size: small;white-space:nowrap";>' +
                            yaniceGraphNodeInfo.command.cwd +
                            '</td>' +
                            '</tr>'
                    );
                }
            }

            // Add dependents if there are any
            if (yaniceGraphNodeInfo.parents.length > 0) {
                table = table.concat(
                    '<tr>' + '  <td>Dependents:</td>' + '  <td>' + yaniceGraphNodeInfo.parents.join(', ') + '</td>' + '</tr>'
                );
            }

            // If there are changed files, list them
            if (yaniceGraphNodeInfo.changedFiles.length > 0) {
                table = table.concat(
                    '  <tr>' +
                        '    <td style="white-space:nowrap">Changed files:</td>' +
                        '    <td><ul style="font-size: x-small;white-space:nowrap;list-style:none;padding:0;margin:0";>' +
                        yaniceGraphNodeInfo.changedFiles.map((f) => '<li>' + f + '</li>').join('') +
                        '</ul></td>' +
                        '  </tr>'
                );
            }
            return table + '</table>';
        }
    </script>
</body>
